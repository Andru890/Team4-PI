import cloneDeep from 'lodash.clonedeep';
import { render } from '../utils/render';
import { VIDEO_MIME_TYPES } from "../utils/internalConstants";
var ANALYTICS_DELIMITER = '?_a=';
var HtmlVideoLayer = /** @class */ (function () {
    function HtmlVideoLayer(element, userCloudinaryVideo, sources, plugins, videoAttributes, userCloudinaryPoster, videoOptions) {
        var _this = this;
        this.mimeType = 'video';
        this.mimeSubTypes = VIDEO_MIME_TYPES;
        this.videoElement = element;
        this.originalVideo = userCloudinaryVideo;
        this.videoOptions = videoOptions;
        this.htmlPluginState = { cleanupCallbacks: [], pluginEventSubscription: [] };
        var pluginCloudinaryVideo = cloneDeep(userCloudinaryVideo);
        render(element, userCloudinaryVideo, plugins, this.htmlPluginState)
            .then(function () {
            _this.htmlPluginState.pluginEventSubscription.forEach(function (fn) { fn(); });
            _this.setVideoAttributes(videoAttributes, userCloudinaryPoster);
            _this.handleSourceToVideo(pluginCloudinaryVideo, sources);
        });
    }
    /**
     * Handles user supplied sources or default sources
     * @param userCloudinaryVideo {CloudinaryVideo}
     * @param sources
     */
    HtmlVideoLayer.prototype.handleSourceToVideo = function (userCloudinaryVideo, sources) {
        var _this = this;
        // checks if user supplied sources
        if (sources) {
            this.generateUserSources(userCloudinaryVideo, sources);
        }
        else {
            var defaultTypes = ['webm', 'mp4', 'ogv'];
            defaultTypes.forEach(function (type) {
                _this.appendSourceTag(cloneDeep(userCloudinaryVideo), type);
            });
        }
    };
    /**
     * Generate sources based on user input
     * @param userCloudinaryVideo {CloudinaryVideo}
     * @param sources
     */
    HtmlVideoLayer.prototype.generateUserSources = function (userCloudinaryVideo, sources) {
        var _this = this;
        sources.map(function (_a) {
            var type = _a.type, codecs = _a.codecs, transcode = _a.transcode;
            return (_this.appendSourceTag(cloneDeep(userCloudinaryVideo)
                .transcode(transcode), type, _this.buildMimeType(type, codecs)));
        });
    };
    /**
     * Appends source tag to html video element
     * @param userCloudinaryVideo {CloudinaryVideo}
     * @param type {string}
     * @param mimeType {string}
     */
    HtmlVideoLayer.prototype.appendSourceTag = function (userCloudinaryVideo, type, mimeType) {
        var _a;
        var source = document.createElement('source');
        var shouldUseFetchFormat = (_a = this.videoOptions) === null || _a === void 0 ? void 0 : _a.useFetchFormat;
        if (shouldUseFetchFormat) {
            userCloudinaryVideo.format(type);
        }
        var url = userCloudinaryVideo.toURL();
        // Split url to get analytics string so that we can insert the file extension (type) before it
        // To simplify this we could add a .getPublicId to CloudinaryVideo and do vid.setPublicId(vid.getPublicId+type)
        // Another option could be to add a .setExtension, which will allow to do vid.setExtension(type)
        var srcParts = url.split(ANALYTICS_DELIMITER);
        var analyticsStr = srcParts[1] ? "".concat(ANALYTICS_DELIMITER).concat(srcParts[1]) : '';
        var ext = shouldUseFetchFormat ? '' : ".".concat(type);
        source.src = "".concat(srcParts[0]).concat(ext).concat(analyticsStr);
        // Ideally, we want to use the VIDEO_MIME_TYPE to detect the mime of the extension
        // For future proofing of simple formats (say .foo and mimetype of video/foo), we also fallback to the actual type
        source.type = mimeType ? mimeType : "video/".concat(VIDEO_MIME_TYPES[type] || type);
        this.videoElement.appendChild(source);
    };
    /**
     * Determines MIME type of given source type and codecs.
     * @param type - format of the video
     * @param codecs - optional information about codecs of the video
     */
    HtmlVideoLayer.prototype.buildMimeType = function (type, codecs) {
        var mimeType = "".concat(this.mimeType, "/").concat(this.mimeSubTypes[type] || type);
        if (codecs) {
            mimeType += "; codecs=" + (Array.isArray(codecs) ? codecs.join(', ') : codecs);
        }
        return mimeType;
    };
    ;
    /**
     * Iterates through the video attributes and sets to true if passed in by the user.
     * In case of poster, sets the poster.
     * @param videoAttributes {object} Supported attributes: controls, loop, muted, poster, preload, autoplay, playsinline
     */
    HtmlVideoLayer.prototype.setVideoAttributes = function (videoAttributes, userCloudinaryPoster) {
        var _a;
        if (videoAttributes === void 0) { videoAttributes = {}; }
        if (userCloudinaryPoster === 'auto') {
            var posterCloudinaryVideo = cloneDeep(this.originalVideo);
            videoAttributes['poster'] = posterCloudinaryVideo
                .quality('auto')
                .format('jpg')
                .addTransformation('so_auto')
                .toURL();
        }
        else if (userCloudinaryPoster) {
            videoAttributes['poster'] = (_a = userCloudinaryPoster.toURL) === null || _a === void 0 ? void 0 : _a.call(userCloudinaryPoster);
        }
        for (var _i = 0, _b = Object.entries(videoAttributes); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            // Boolean attributes are considered to be true if they're present on the element at all.
            // You should set value to the empty string ("") or the attribute's name.
            // See https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
            value && this.videoElement.setAttribute(key, key === 'poster' ? value : '');
        }
    };
    /**
     * Called when component is updated. If our video source has changed, a video reload is triggered.
     * @param updatedCloudinaryVideo
     * @param sources
     * @param plugins
     * @param videoAttributes
     */
    HtmlVideoLayer.prototype.update = function (updatedCloudinaryVideo, sources, plugins, videoAttributes, userCloudinaryPoster) {
        var _this = this;
        if (updatedCloudinaryVideo !== this.originalVideo) {
            var sourcesToDelete = this.videoElement.getElementsByTagName("SOURCE");
            while (sourcesToDelete[0])
                sourcesToDelete[0].parentNode.removeChild(sourcesToDelete[0]);
            render(this.videoElement, updatedCloudinaryVideo, plugins, this.htmlPluginState)
                .then(function () {
                _this.setVideoAttributes(videoAttributes, userCloudinaryPoster);
                _this.handleSourceToVideo(updatedCloudinaryVideo, sources);
                _this.videoElement.load();
            });
        }
    };
    return HtmlVideoLayer;
}());
export { HtmlVideoLayer };
